Explications des signaux et des exit status en bash (man bash)

EXIT_STATUS:

L'état de sortie d'une commande exécutée est la valeur renvoyée par l'appel système waitpid ou une fonction équivalente. 
Les états de sortie sont compris entre 0 et 255, bien que, comme expliqué ci-dessous, 
l'interpréteur de commandes puisse utiliser spécialement des valeurs supérieures à 125. 
Les états de sortie des constructions de l'interpréteur de commandes et des commandes composées sont également limités à cette plage.
Dans certaines circonstances, l'interpréteur de commandes utilisera des valeurs spéciales pour indiquer des modes d'échec spécifiques. 

Pour les besoins de l'interpréteur de commandes, une commande qui sort avec un état de sortie nul a réussi.
Un état de sortie non nul indique un échec. Ce schéma apparemment contre-intuitif est utilisé pour qu'il y 
ait une façon bien définie d'indiquer le succès et une variété de façons d'indiquer les différents modes d'échec.
Lorsqu'une commande se termine sur un signal fatal dont le numéro est N, Bash utilise la valeur 128+N comme état de sortie. 

Si une commande n'est pas trouvée, le processus enfant créé pour l'exécuter renvoie un état de 127. 
Si une commande est trouvée mais n'est pas exécutable, l'état de retour est 126.

Si une commande échoue en raison d'une erreur au cours de l'expansion ou de la redirection, l'état de sortie est supérieur à zéro.

L'état de sortie est utilisé par les commandes conditionnelles de Bash (voir Constructions conditionnelles) 
et certaines constructions de listes (voir Listes de commandes).

Toutes les constructions Bash renvoient un état de sortie égal à zéro en cas de succès et un état différent de zéro en cas d'échec, 
de sorte qu'elles peuvent être utilisées par les constructions conditionnelles et les constructions de listes. 
Toutes les commandes intégrées renvoient un état de sortie de 2 pour indiquer une utilisation incorrecte, 
généralement des options non valides ou des arguments manquants.

L'état de sortie de la dernière commande est disponible dans le paramètre spécial $ ? (voir Paramètres spéciaux). 

SIGNAL:

Lorsque Bash est interactif, en l'absence de pièges, il ignore SIGTERM (de sorte que « kill 0 » ne tue pas un shell interactif),
et SIGINT est capturé et géré (de sorte que le builtin wait est interruptible). 
Lorsque Bash reçoit un SIGINT, il sort de toute boucle d'exécution. Dans tous les cas, Bash ignore SIGQUIT. 
Si le contrôle des tâches est en vigueur (voir Contrôle des tâches), Bash ignore SIGTTIN, SIGTTOU et SIGTSTP. 

Les commandes non-construites lancées par Bash ont des gestionnaires de signaux réglés sur les valeurs 
héritées par l'interpréteur de commandes de son parent. Lorsque le contrôle des tâches n'est pas en vigueur, 
les commandes asynchrones ignorent SIGINT et SIGQUIT en plus de ces gestionnaires hérités. 
Les commandes exécutées à la suite d'une substitution de commande ignorent les signaux 
SIGTTIN, SIGTTOU et SIGTSTP générés par le clavier pour le contrôle des tâches. 

L'interpréteur de commandes quitte par défaut à la réception d'un SIGHUP. 
Avant de quitter, un shell interactif renvoie le SIGHUP à tous les travaux, en cours ou arrêtés. 
Les travaux arrêtés reçoivent le signal SIGCONT pour s'assurer qu'ils reçoivent le SIGHUP. 
Pour empêcher l'interpréteur de commandes d'envoyer le signal SIGHUP à un travail particulier, 
celui-ci doit être supprimé de la table des travaux à l'aide du module disown (voir Modules de contrôle des travaux) 
ou marqué comme ne recevant pas le signal SIGHUP à l'aide de disown -h. 

Si l'option de shell huponexit a été définie avec shopt (voir The Shopt Builtin), 
Bash envoie un SIGHUP à tous les jobs lorsqu'un shell de connexion interactif se termine. 

Si Bash attend la fin d'une commande et reçoit un signal pour lequel un piège a été défini, 
le piège ne sera pas exécuté tant que la commande ne sera pas terminée. 
Lorsque Bash attend une commande asynchrone via le module d'attente, 
la réception d'un signal pour lequel un piège a été défini entraîne le retour 
immédiat du module d'attente avec un état de sortie supérieur à 128, après quoi le piège est exécuté. 

Lorsque le contrôle des tâches n'est pas activé et que Bash attend la fin d'une commande d'avant-plan, 
l'interpréteur de commandes reçoit des signaux générés par le clavier, tels que SIGINT (généralement généré par '^C'), 
que les utilisateurs ont généralement l'intention d'envoyer à cette commande. Cela se produit parce que 
l'interpréteur de commandes et la commande se trouvent dans le même groupe de processus que le terminal, et 
que '^C' envoie SIGINT à tous les processus de ce groupe de processus. Voir Job Control, pour une discussion 
plus approfondie sur les groupes de processus. 

Lorsque Bash est exécuté sans que le contrôle des tâches soit activé et qu'il reçoit 
un SIGINT alors qu'il attend une commande au premier plan, il attend que cette commande au premier 
plan se termine et décide alors de ce qu'il convient de faire du SIGINT : 

1. Si la commande se termine à cause du SIGINT, Bash en conclut que l'utilisateur voulait mettre fin à l'ensemble du 
script et agit en conséquence (par exemple, en lançant un piège SIGINT ou en se quittant lui-même) ; 

2. Si le pipeline ne se termine pas à cause d'un SIGINT, le programme a géré le SIGINT lui-même et ne l'a pas traité 
comme un signal fatal. Dans ce cas, Bash ne traite pas non plus le SIGINT comme un signal fatal, 
supposant que le SIGINT a été utilisé dans le cadre du fonctionnement normal du programme 
(par exemple, emacs l'utilise pour interrompre les commandes d'édition) ou qu'il a été délibérément supprimé. 
Cependant, Bash exécutera tout piège défini sur SIGINT, comme il le fait avec tout autre signal piégé 
qu'il reçoit pendant qu'il attend la fin de la commande de premier plan, pour des raisons de compatibilité. 